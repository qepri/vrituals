<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZYZYX Breathing Mandala</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        .bloom {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            filter: blur(20px);
            opacity: 0.5;
            mix-blend-mode: screen;
        }
    </style>
</head>
<body>
    <div class="bloom"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.157.0/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create the central geometry with more complex structure
        const createCentralMandala = () => {
            const group = new THREE.Group();
            
            // Create multiple layers of geometric shapes
            for(let i = 0; i < 8; i++) {
                const radius = 1 + i * 0.2;
                const segments = 8;
                const geometry = new THREE.CircleGeometry(radius, segments);
                
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00bcd4,
                    emissive: 0x0088aa,
                    specular: 0x00ffff,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = Math.PI / 2;
                
                // Create duplicate rotated planes for more complex pattern
                for(let j = 0; j < 8; j++) {
                    const clone = mesh.clone();
                    clone.rotation.z = (Math.PI / 4) * j;
                    group.add(clone);
                }
            }
            
            return group;
        };

        // Create outer rings with more detail
        const createDetailedRing = (radius, segments, tubeRadius = 0.05) => {
            const group = new THREE.Group();
            
            // Main ring
            const geometry = new THREE.TorusGeometry(radius, tubeRadius, 16, segments);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4a148c,
                emissive: 0x2a0845,
                specular: 0x6a1b9a,
                shininess: 100,
                transparent: true,
                opacity: 0.8
            });
            
            const mainRing = new THREE.Mesh(geometry, material);
            group.add(mainRing);
            
            // Add decorative elements around the ring
            for(let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const decorGeometry = new THREE.ConeGeometry(tubeRadius * 2, tubeRadius * 4, 4);
                const decorMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x00bcd4,
                    transparent: true,
                    opacity: 0.9
                });
                
                const decor = new THREE.Mesh(decorGeometry, decorMaterial);
                decor.position.x = Math.cos(angle) * radius;
                decor.position.y = Math.sin(angle) * radius;
                decor.rotation.z = angle + Math.PI / 2;
                group.add(decor);
            }
            
            return group;
        };

        // Enhanced particle system
        const createEnhancedParticles = () => {
            const geometry = new THREE.BufferGeometry();
            const particles = 2000;
            const positions = new Float32Array(particles * 3);
            const colors = new Float32Array(particles * 3);
            
            for(let i = 0; i < particles * 3; i += 3) {
                const radius = THREE.MathUtils.randFloat(3, 6);
                const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
                const phi = THREE.MathUtils.randFloat(0, Math.PI);
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = radius * Math.cos(phi);
                
                // Add color variation
                colors[i] = THREE.MathUtils.randFloat(0, 1);
                colors[i + 1] = THREE.MathUtils.randFloat(0.5, 1);
                colors[i + 2] = 1;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            return new THREE.Points(geometry, material);
        };

        // Create main objects
        const mandala = createCentralMandala();
        const outerRing1 = createDetailedRing(2.5, 32);
        const outerRing2 = createDetailedRing(3, 32);
        const particles = createEnhancedParticles();

        // Enhanced lighting
        const light1 = new THREE.PointLight(0x00ffff, 2, 50);
        light1.position.set(5, 5, 5);
        const light2 = new THREE.PointLight(0x4a148c, 2, 50);
        light2.position.set(-5, -5, -5);
        const ambientLight = new THREE.AmbientLight(0x404040);

        scene.add(mandala);
        scene.add(outerRing1);
        scene.add(outerRing2);
        scene.add(particles);
        scene.add(light1);
        scene.add(light2);
        scene.add(ambientLight);

        camera.position.z = 5;

        // Breathing animation
        let time = 0;
        const animate = () => {
            requestAnimationFrame(animate);
            time += 0.01;

            // Breathing effect
            const breathingScale = 1 + Math.sin(time) * 0.05;
            mandala.scale.set(breathingScale, breathingScale, breathingScale);
            
            // Very slow rotation
            mandala.rotation.z += 0.001;
            
            outerRing1.rotation.z += 0.002;
            outerRing2.rotation.z -= 0.001;

            // Gentle particle movement
            particles.rotation.y += 0.0005;
            
            // Light movement
            light1.position.x = Math.sin(time * 0.5) * 5;
            light1.position.y = Math.cos(time * 0.5) * 5;
            light2.position.x = -Math.sin(time * 0.3) * 5;
            light2.position.y = -Math.cos(time * 0.3) * 5;

            renderer.render(scene, camera);
            
            // Update bloom effect
            const bloomElement = document.querySelector('.bloom');
            bloomElement.style.background = `
                radial-gradient(circle at 50% 50%, 
                rgba(0, 188, 212, ${0.3 + Math.sin(time) * 0.1}),
                rgba(74, 20, 140, ${0.2 + Math.cos(time) * 0.1}),
                transparent 70%)
            `;
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>